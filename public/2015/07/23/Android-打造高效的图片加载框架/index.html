<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="1、概述优秀的图片加载框架不要太多，什么UIL , Volley,Picasso,Imageloader等等。但是作为一名合格的程序猿，必须懂其中的实现原理，于是乎，今天我就带大家一起来设计一个加载网络、本地的图片框架。有人可能会说，自己写会不会很渣，运行效率，内存溢出神马的。放心，我们拿demo说话，拼得就是速度，奏事这么任性。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 打造高效的图片加载框架">
<meta property="og:url" content="http://mandroid.cn/2015/07/23/Android-打造高效的图片加载框架/index.html">
<meta property="og:site_name" content="测试">
<meta property="og:description" content="1、概述优秀的图片加载框架不要太多，什么UIL , Volley,Picasso,Imageloader等等。但是作为一名合格的程序猿，必须懂其中的实现原理，于是乎，今天我就带大家一起来设计一个加载网络、本地的图片框架。有人可能会说，自己写会不会很渣，运行效率，内存溢出神马的。放心，我们拿demo说话，拼得就是速度，奏事这么任性。">
<meta property="og:image" content="http://mandroid.cn/upload/2015/07/201507231437642603106757.gif">
<meta property="og:image" content="http://mandroid.cn/upload/2015/07/201507231437642625119761.png">
<meta property="og:updated_time" content="2016-03-18T02:34:16.952Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 打造高效的图片加载框架">
<meta name="twitter:description" content="1、概述优秀的图片加载框架不要太多，什么UIL , Volley,Picasso,Imageloader等等。但是作为一名合格的程序猿，必须懂其中的实现原理，于是乎，今天我就带大家一起来设计一个加载网络、本地的图片框架。有人可能会说，自己写会不会很渣，运行效率，内存溢出神马的。放心，我们拿demo说话，拼得就是速度，奏事这么任性。">
<meta name="twitter:image" content="http://mandroid.cn/upload/2015/07/201507231437642603106757.gif">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Android 打造高效的图片加载框架 | 测试 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">测试</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">子标签</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android 打造高效的图片加载框架
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-23T16:57:43+08:00" content="2015-07-23">
              2015-07-23
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p>优秀的图片加载框架不要太多，什么UIL , Volley<br>,Picasso,Imageloader等等。但是作为一名合格的程序猿，必须懂其中的实现原理，于是乎，今天我就带大家一起来设计一个加载网络、本地<br>的图片框架。有人可能会说，自己写会不会很渣，运行效率，内存溢出神马的。放心，我们拿demo说话，拼得就是速度，奏事这么任性。<br><a id="more"></a><br>好了，如果你看过之前的博文，类似Android<br> Handler 异步消息处理机制的妙用 创建强大的图片加载类，可能会对接下来文章理解会有很大的帮助。没有的话，就跟我往下继续走吧，也不要去看了。</p>
<p>关于加载本地图片，当然了，我手机图片比较少，7000来张：</p>
<p>1、首先肯定不能内存溢出，但是尼玛现在像素那么高，怎么才能保证呢？我相信利用LruCache统一管理你的图片是个不二的选择，所有的图片从LruCache里面取，保证所有的图片的内存不会超过预设的空间。</p>
<p>2、加载速度要刚刚的，我一用力，滑动到3000张的位置，你要是还在从第一张给我加载，尼玛，你以为我打dota呢。所以我们需要引入加载策略，我们不能FIFO，我们选择LIFO，当前呈现给用户的，最新加载；当前未呈现的，选择加载。</p>
<p>3、使用方便。一般图片都会使用GridView作为控件，在getView里面进行图片加载，当然了为了不错乱，可能还需要用户去自己setTag，自<br>己写回调设置图片。当然了，我们不需要这么麻烦，一句话IoadImage(imageview,path）即可，剩下的请交给我们的图片加载框架处理。</p>
<p>做到以上几点，关于本地的图片加载应该就木有什么问题了。</p>
<p>关于加载网络图片，其实原理差不多，就多了个是否启用硬盘缓存的选项，如果启用了，加载时，先从内存中查找，然后从硬盘上找，最后去网络下载。下载完成后，别忘了写入硬盘，加入内存缓存。如果没有启用，那么就直接从网络压缩获取，加入内存即可。</p>
<h1 id="2、效果图"><a href="#2、效果图" class="headerlink" title="2、效果图"></a><a name="t1"></a><a target="_blank" style="color:rgb(51,102,153)" name="t1"></a>2、效果图</h1><p>终于扯完了，接下来，简单看个效果图，关于加载本地图片的效果图：可以从Android<br> 超高仿微信图片选择器 图片该这么加载这篇博客中下载Demo运行。</p>
<p>下面演示一个网络加载图片的例子:</p>
<p><img src="/upload/2015/07/201507231437642603106757.gif" alt="20141211214442177.gif" title="201507231437642603106757.gif"></p>
<p>80多张从网络加载的图片，可以看到我直接拖到最后，基本是呈现在用户眼前的最先加载，要是从第一张到80多，估计也是醉了。</p>
<p>此外：图片来自老郭的博客，感谢！！！ps:如果你觉得图片不劲爆，Day Day Up找老郭去。</p>
<h1 id="3、完全解析"><a href="#3、完全解析" class="headerlink" title="3、完全解析"></a>3、完全解析</h1><div style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></div>

<h2 id="1、关于图片的压缩"><a href="#1、关于图片的压缩" class="headerlink" title="1、关于图片的压缩"></a>1、关于图片的压缩</h2><p>不管是从网络还是本地的图片，加载都需要进行压缩，然后显示：</p>
<p>用户要你压缩显示，会给我们什么？一个imageview，一个path，我们的职责就是压缩完成后显示上去。</p>
<h3 id="1、本地图片的压缩"><a href="#1、本地图片的压缩" class="headerlink" title="1、本地图片的压缩"></a>1、本地图片的压缩</h3><div style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></div>

<p><strong>a、获得imageview想要显示的大小</strong></p>
<p>想要压缩，我们第一步应该是获得imageview想要显示的大小，没大小肯定没办法压缩？</p>
<p>那么如何获得imageview想要显示的大小呢？</p>
<pre class="brush:java;toolbar:false">    /** 
         * 根据ImageView获适当的压缩的宽和高 
         *  
         * @param imageView 
         * @return 
         */  
        public static ImageSize getImageViewSize(ImageView imageView)  
        {  

            ImageSize imageSize = new ImageSize();  
            DisplayMetrics displayMetrics = imageView.getContext().getResources()  
                    .getDisplayMetrics();  

            LayoutParams lp = imageView.getLayoutParams();  

            int width = imageView.getWidth();// 获取imageview的实际宽度  
            if (width &lt;= 0)  
            {  
                width = lp.width;// 获取imageview在layout中声明的宽度  
            }  
            if (width &lt;= 0)  
            {  
                // width = imageView.getMaxWidth();// 检查最大值  
                width = getImageViewFieldValue(imageView, &quot;mMaxWidth&quot;);  
            }  
            if (width &lt;= 0)  
            {  
                width = displayMetrics.widthPixels;  
            }  

            int height = imageView.getHeight();// 获取imageview的实际高度  
            if (height &lt;= 0)  
            {  
                height = lp.height;// 获取imageview在layout中声明的宽度  
            }  
            if (height &lt;= 0)  
            {  
                height = getImageViewFieldValue(imageView, &quot;mMaxHeight&quot;);// 检查最大值  
            }  
            if (height &lt;= 0)  
            {  
                height = displayMetrics.heightPixels;  
            }  
            imageSize.width = width;  
            imageSize.height = height;  

            return imageSize;  
        }  

        public static class ImageSize  
        {  
            int width;  
            int height;  
        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">可以看到，我们拿到imageview以后：</span></p>
<p>首先企图通过getWidth获取显示的宽；有些时候，这个getWidth返回的是0；</p>
<p>那么我们再去看看它有没有在布局文件中书写宽；</p>
<p>如果布局文件中也没有精确值，那么我们再去看看它有没有设置最大值；</p>
<p>如果最大值也没设置，那么我们只有拿出我们的终极方案，使用我们的屏幕宽度；</p>
<p>总之，不能让它任性，我们一定要拿到一个合适的显示值。</p>
<p>可以看到这里或者最大宽度，我们用的反射，而不是getMaxWidth()；维萨呢，因为getMaxWidth竟然要API 16，我也是醉了；为了兼容性，我们采用反射的方案。反射的代码就不贴了。</p>
<p><strong>b、设置合适的inSampleSize</strong></p>
<p>我们获得想要显示的大小，为了什么，还不是为了和图片的真正的宽高做比较，拿到一个合适的inSampleSize，去对图片进行压缩么。</p>
<p>那么首先应该是拿到图片的宽和高：</p>
<pre class="brush:java;toolbar:false"> // 获得图片的宽和高，并不把图片加载到内存中  
        BitmapFactory.Options options = new BitmapFactory.Options();  
        options.inJustDecodeBounds = true;  
        BitmapFactory.decodeFile(path, options);</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这三行就成功获取图片真正的宽和高了，存在我们的options里面；</span></p>
<p>然后我们就可以happy的去计算inSampleSize了：</p>
<pre class="brush:java;toolbar:false">    /** 
         * 根据需求的宽和高以及图片实际的宽和高计算SampleSize 
         *  
         * @param options 
         * @param width 
         * @param height 
         * @return 
         */  
        public static int caculateInSampleSize(Options options, int reqWidth,  
                int reqHeight)  
        {  
            int width = options.outWidth;  
            int height = options.outHeight;  

            int inSampleSize = 1;  

            if (width &gt; reqWidth || height &gt; reqHeight)  
            {  
                int widthRadio = Math.round(width * 1.0f / reqWidth);  
                int heightRadio = Math.round(height * 1.0f / reqHeight);  

                inSampleSize = Math.max(widthRadio, heightRadio);  
            }  

            return inSampleSize;  
        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">options里面存了实际的宽和高；reqWidth和reqHeight就是我们之前得到的想要显示的大小；经过比较，得到一个合适的inSampleSize;</span></p>
<p>有了inSampleSize:</p>
<pre class="brush:java;toolbar:false">    options.inSampleSize = ImageSizeUtil.caculateInSampleSize(options,  
                    width, height);  

            // 使用获得到的InSampleSize再次解析图片  
            options.inJustDecodeBounds = false;  
            Bitmap bitmap = BitmapFactory.decodeFile(path, options);  
            return bitmap;</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">经过这几行，就完成图片的压缩了。</span></p>
<p>上述是本地图片的压缩，那么如果是网络图片呢？</p>
<h3 id="2、网络图片的压缩"><a href="#2、网络图片的压缩" class="headerlink" title="2、网络图片的压缩"></a>2、网络图片的压缩</h3><div style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></div>

<p><strong>a、直接下载存到sd卡，然后采用本地的压缩方案。这种方式当前是在硬盘缓存开启的情况下，如果没有开启呢？</strong></p>
<p><strong>b、使用BitmapFactory.decodeStream(is, null, opts);</strong></p>
<pre class="brush:java;toolbar:false">    /** 
         * 根据url下载图片在指定的文件 
         *  
         * @param urlStr 
         * @param file 
         * @return 
         */  
        public static Bitmap downloadImgByUrl(String urlStr, ImageView imageview)  
        {  
            FileOutputStream fos = null;  
            InputStream is = null;  
            try  
            {  
                URL url = new URL(urlStr);  
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();  
                is = new BufferedInputStream(conn.getInputStream());  
                is.mark(is.available());  

                Options opts = new Options();  
                opts.inJustDecodeBounds = true;  
                Bitmap bitmap = BitmapFactory.decodeStream(is, null, opts);  

                //获取imageview想要显示的宽和高  
                ImageSize imageViewSize = ImageSizeUtil.getImageViewSize(imageview);  
                opts.inSampleSize = ImageSizeUtil.caculateInSampleSize(opts,  
                        imageViewSize.width, imageViewSize.height);  

                opts.inJustDecodeBounds = false;  
                is.reset();  
                bitmap = BitmapFactory.decodeStream(is, null, opts);  

                conn.disconnect();  
                return bitmap;  

            } catch (Exception e)  
            {  
                e.printStackTrace();  
            } finally  
            {  
                try  
                {  
                    if (is != null)  
                        is.close();  
                } catch (IOException e)  
                {  
                }  

                try  
                {  
                    if (fos != null)  
                        fos.close();  
                } catch (IOException e)  
                {  
                }  
            }  

            return null;  

        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">基本和本地压缩差不多，也是两次取样，当然需要注意一点，我们的is进行了包装，以便可以进行reset()；直接返回的is是不能使用两次的。</span></p>
<p>到此，图片压缩说完了。</p>
<h2 id="2、图片加载框架的架构"><a href="#2、图片加载框架的架构" class="headerlink" title="2、图片加载框架的架构"></a><a name="t6"></a><a target="_blank" style="color:rgb(51,102,153)" name="t6"></a>2、图片加载框架的架构</h2><p>我们的图片压缩加载完了，那么就应该放入我们的LruCache，然后设置到我们的ImageView上。</p>
<p>好了，接下来我们来说说我们的这个框架的架构；</p>
<p>1、单例，包含一个LruCache用于管理我们的图片；</p>
<p>2、任务队列，我们每来一次加载图片的请求，我们会封装成Task存入我们的TaskQueue;</p>
<p>3、包含一个后台线程，这个线程在第一次初始化实例的时候启动，然后会一直在后台运行；任务呢？还记得我们有个任务队列么，有队列存任务，得有人干活呀；<br>所以，当每来一次加载图片请求的时候，我们同时发一个消息到后台线程，后台线程去使用线程池去TaskQueue去取一个任务执行；</p>
<p>4、调度策略；3中说了，后台线程去TaskQueue去取一个任务，这个任务不是随便取的，有策略可以选择，一个是FIFO，一个是LIFO，我倾向于后者。</p>
<p>好了，基本就这些结构，接下来看我们具体的实现。</p>
<h1 id="3、具体的实现"><a href="#3、具体的实现" class="headerlink" title="3、具体的实现"></a><a name="t7"></a><a target="_blank" style="color:rgb(51,102,153)" name="t7"></a>3、具体的实现</h1><div style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br></div>

<h2 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a><a name="t8"></a><a target="_blank" style="color:rgb(51,102,153)" name="t8"></a>1、构造方法</h2><pre class="brush:java;toolbar:false">    public static ImageLoader getInstance(int threadCount, Type type)  
        {  
            if (mInstance == null)  
            {  
                synchronized (ImageLoader.class)  
                {  
                    if (mInstance == null)  
                    {  
                        mInstance = new ImageLoader(threadCount, type);  
                    }  
                }  
            }  
            return mInstance;  
        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这个就不用说了，重点看我们的构造方法</span></p>
<pre class="brush:java;toolbar:false">  /** 
     * 图片加载类 
     *  
     * @author zhy 
     *  
     */  
    public class ImageLoader  
    {  
        private static ImageLoader mInstance;  

        /** 
         * 图片缓存的核心对象 
         */  
        private LruCache&lt;String, Bitmap&gt; mLruCache;  
        /** 
         * 线程池 
         */  
        private ExecutorService mThreadPool;  
        private static final int DEAFULT_THREAD_COUNT = 1;  
        /** 
         * 队列的调度方式 
         */  
        private Type mType = Type.LIFO;  
        /** 
         * 任务队列 
         */  
        private LinkedList&lt;Runnable&gt; mTaskQueue;  
        /** 
         * 后台轮询线程 
         */  
        private Thread mPoolThread;  
        private Handler mPoolThreadHandler;  
        /** 
         * UI线程中的Handler 
         */  
        private Handler mUIHandler;  

        private Semaphore mSemaphorePoolThreadHandler = new Semaphore(0);  
        private Semaphore mSemaphoreThreadPool;  

        private boolean isDiskCacheEnable = true;  

        private static final String TAG = &quot;ImageLoader&quot;;  

        public enum Type  
        {  
            FIFO, LIFO;  
        }  

        private ImageLoader(int threadCount, Type type)  
        {  
            init(threadCount, type);  
        }  

        /** 
         * 初始化 
         *  
         * @param threadCount 
         * @param type 
         */  
        private void init(int threadCount, Type type)  
        {  
            initBackThread();  

            // 获取我们应用的最大可用内存  
            int maxMemory = (int) Runtime.getRuntime().maxMemory();  
            int cacheMemory = maxMemory / 8;  
            mLruCache = new LruCache&lt;String, Bitmap&gt;(cacheMemory)  
            {  
                @Override  
                protected int sizeOf(String key, Bitmap value)  
                {  
                    return value.getRowBytes() * value.getHeight();  
                }  

            };  

            // 创建线程池  
            mThreadPool = Executors.newFixedThreadPool(threadCount);  
            mTaskQueue = new LinkedList&lt;Runnable&gt;();  
            mType = type;  
            mSemaphoreThreadPool = new Semaphore(threadCount);  
        }  

        /** 
         * 初始化后台轮询线程 
         */  
        private void initBackThread()  
        {  
            // 后台轮询线程  
            mPoolThread = new Thread()  
            {  
                @Override  
                public void run()  
                {  
                    Looper.prepare();  
                    mPoolThreadHandler = new Handler()  
                    {  
                        @Override  
                        public void handleMessage(Message msg)  
                        {  
                            // 线程池去取出一个任务进行执行  
                            mThreadPool.execute(getTask());  
                            try  
                            {  
                                mSemaphoreThreadPool.acquire();  
                            } catch (InterruptedException e)  
                            {  
                            }  
                        }  
                    };  
                    // 释放一个信号量  
                    mSemaphorePoolThreadHandler.release();  
                    Looper.loop();  
                };  
            };  

            mPoolThread.start();  
        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">在贴构造的时候，顺便贴出所有的成员变量；</span></p>
<p>在构造中我们调用init，init中可以设置后台加载图片线程数量和加载策略；init中首先初始化后台线程initBackThread(),可以看<br>到这个后台线程，实际上是个Looper最终在那不断的loop，我们还初始化了一个mPoolThreadHandler用于发送消息到此线程；</p>
<p>接下来就是初始化mLruCache  ， mThreadPool ，mTaskQueue 等；</p>
<h2 id="2、loadImage"><a href="#2、loadImage" class="headerlink" title="2、loadImage"></a><a name="t9"></a><a target="_blank" style="color:rgb(51,102,153)" name="t9"></a>2、loadImage</h2><p>构造完成以后，当然是使用了，用户调用loadImage传入(final String path, final ImageView imageView,final boolean isFromNet)就可以完成本地或者网络图片的加载。</p>
<pre class="brush:java;toolbar:false"> /** 
         * 根据path为imageview设置图片 
         *  
         * @param path 
         * @param imageView 
         */  
        public void loadImage(final String path, final ImageView imageView,  
                final boolean isFromNet)  
        {  
            imageView.setTag(path);  
            if (mUIHandler == null)  
            {  
                mUIHandler = new Handler()  
                {  
                    public void handleMessage(Message msg)  
                    {  
                        // 获取得到图片，为imageview回调设置图片  
                        ImgBeanHolder holder = (ImgBeanHolder) msg.obj;  
                        Bitmap bm = holder.bitmap;  
                        ImageView imageview = holder.imageView;  
                        String path = holder.path;  
                        // 将path与getTag存储路径进行比较  
                        if (imageview.getTag().toString().equals(path))  
                        {  
                            imageview.setImageBitmap(bm);  
                        }  
                    };  
                };  
            }  

            // 根据path在缓存中获取bitmap  
            Bitmap bm = getBitmapFromLruCache(path);  

            if (bm != null)  
            {  
                refreashBitmap(path, imageView, bm);  
            } else  
            {  
                addTask(buildTask(path, imageView, isFromNet));  
            }  

        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">首先我们为imageview.setTag；然后初始化一个mUIHandler，不用猜，这个mUIHandler用户更新我们的imageview，因为这个方法肯定是主线程调用的。</span></p>
<p>然后调用：getBitmapFromLruCache(path);根据path在缓存中获取bitmap；如果找到那么直接去设置我们的图片；</p>
<pre class="brush:java;toolbar:false"> private void refreashBitmap(final String path, final ImageView imageView,  
            Bitmap bm)  
    {  
        Message message = Message.obtain();  
        ImgBeanHolder holder = new ImgBeanHolder();  
        holder.bitmap = bm;  
        holder.path = path;  
        holder.imageView = imageView;  
        message.obj = holder;  
        mUIHandler.sendMessage(message);  
    }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">可以看到，如果找到图片，则直接使用UIHandler去发送一个消息，当然了携带了一些必要的参数，然后UIHandler的handleMessage中完成图片的设置；</span></p>
<p>handleMessage中拿到path,bitmap,imageview；记得必须要：</p>
<p>// 将path与getTag存储路径进行比较<br><span style="white-space:pre"></span></p>
<pre class="brush:java;toolbar:false">if (imageview.getTag().toString().equals(path))
{
imageview.setImageBitmap(bm);
}</pre>

<p>否则会造成图片混乱。</p>
<p>如果没找到，则通过buildTask去新建一个任务，在addTask到任务队列。</p>
<p>buildTask就比较复杂了，因为还涉及到本地和网络，所以我们先看addTask代码：</p>
<pre class="brush:java;toolbar:false"> private synchronized void addTask(Runnable runnable)  
        {  
            mTaskQueue.add(runnable);  
            // if(mPoolThreadHandler==null)wait();  
            try  
            {  
                if (mPoolThreadHandler == null)  
                    mSemaphorePoolThreadHandler.acquire();  
            } catch (InterruptedException e)  
            {  
            }  
            mPoolThreadHandler.sendEmptyMessage(0x110);  
        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">很简单，就是runnable加入TaskQueue，与此同时使用mPoolThreadHandler（这个handler还记得么，用于和我们后台线程交互。）去发送一个消息给后台线程，叫它去取出一个任务执行；具体代码：</span></p>
<pre class="brush:java;toolbar:false">    mPoolThreadHandler = new Handler()  
                    {  
                        @Override  
                        public void handleMessage(Message msg)  
                        {  
                            // 线程池去取出一个任务进行执行  
                            mThreadPool.execute(getTask());</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">直接使用mThreadPool线程池，然后使用getTask去取一个任务。</span></p>
<pre class="brush:java;toolbar:false">    /** 
         * 从任务队列取出一个方法 
         *  
         * @return 
         */  
        private Runnable getTask()  
        {  
            if (mType == Type.FIFO)  
            {  
                return mTaskQueue.removeFirst();  
            } else if (mType == Type.LIFO)  
            {  
                return mTaskQueue.removeLast();  
            }  
            return null;  
        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">getTask代码也比较简单，就是根据Type从任务队列头或者尾进行取任务。</span></p>
<p>现在你会不会好奇，任务里面到底什么代码？其实我们也就剩最后一段代码了buildTask</p>
<pre class="brush:java;toolbar:false">    /** 
         * 根据传入的参数，新建一个任务 
         *  
         * @param path 
         * @param imageView 
         * @param isFromNet 
         * @return 
         */  
        private Runnable buildTask(final String path, final ImageView imageView,  
                final boolean isFromNet)  
        {  
            return new Runnable()  
            {  
                @Override  
                public void run()  
                {  
                    Bitmap bm = null;  
                    if (isFromNet)  
                    {  
                        File file = getDiskCacheDir(imageView.getContext(),  
                                md5(path));  
                        if (file.exists())// 如果在缓存文件中发现  
                        {  
                            Log.e(TAG, &quot;find image :&quot; + path + &quot; in disk cache .&quot;);  
                            bm = loadImageFromLocal(file.getAbsolutePath(),  
                                    imageView);  
                        } else  
                        {  
                            if (isDiskCacheEnable)// 检测是否开启硬盘缓存  
                            {  
                                boolean downloadState = DownloadImgUtils  
                                        .downloadImgByUrl(path, file);  
                                if (downloadState)// 如果下载成功  
                                {  
                                    Log.e(TAG,  
                                            &quot;download image :&quot; + path  
                                                    + &quot; to disk cache . path is &quot;  
                                                    + file.getAbsolutePath());  
                                    bm = loadImageFromLocal(file.getAbsolutePath(),  
                                            imageView);  
                                }  
                            } else  
                            // 直接从网络加载  
                            {  
                                Log.e(TAG, &quot;load image :&quot; + path + &quot; to memory.&quot;);  
                                bm = DownloadImgUtils.downloadImgByUrl(path,  
                                        imageView);  
                            }  
                        }  
                    } else  
                    {  
                        bm = loadImageFromLocal(path, imageView);  
                    }  
                    // 3、把图片加入到缓存  
                    addBitmapToLruCache(path, bm);  
                    refreashBitmap(path, imageView, bm);  
                    mSemaphoreThreadPool.release();  
                }  


            };  
        }  

        private Bitmap loadImageFromLocal(final String path,  
                final ImageView imageView)  
        {  
            Bitmap bm;  
            // 加载图片  
            // 图片的压缩  
            // 1、获得图片需要显示的大小  
            ImageSize imageSize = ImageSizeUtil.getImageViewSize(imageView);  
            // 2、压缩图片  
            bm = decodeSampledBitmapFromPath(path, imageSize.width,  
                    imageSize.height);  
            return bm;  
        }</pre>

<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">我们新建任务，说明在内存中没有找到缓存的bitmap；我们的任务就是去根据path加载压缩后的bitmap返回即可，然后加入LruCache，设置回调显示。</span></p>
<p>首先我们判断是否是网络任务？</p>
<p>如果是，首先去硬盘缓存中找一下，（硬盘中文件名为：根据path生成的md5为名称）。</p>
<p>如果硬盘缓存中没有，那么去判断是否开启了硬盘缓存：</p>
<p><span style="white-space:pre"></span>开启了的话：下载图片，使用loadImageFromLocal本地加载图片的方式进行加载（压缩的代码前面已经详细说过）；</p>
<pre><code>如果没有开启：则直接从网络获取（压缩获取的代码，前面详细说过）；
</code></pre><p>如果不是网络图片：直接loadImageFromLocal本地加载图片的方式进行加载</p>
<p>经过上面，就获得了bitmap；然后加入addBitmapToLruCache，refreashBitmap回调显示图片。</p>
<pre class="brush:java;toolbar:false">    /** 
         * 将图片加入LruCache 
         *  
         * @param path 
         * @param bm 
         */  
        protected void addBitmapToLruCache(String path, Bitmap bm)  
        {  
            if (getBitmapFromLruCache(path) == null)  
            {  
                if (bm != null)  
                    mLruCache.put(path, bm);  
            }  
        }</pre>

<p>到此，我们所有的代码就分析完成了；</p>
<p>缓存的图片位置：在SD卡的Android/data/项目packageName/cache中：</p>
<p><img src="/upload/2015/07/201507231437642625119761.png" alt="20141211225817125.png" title="201507231437642625119761.png"></p>
<p>不过有些地方需要注意：就是在代码中，你会看到一些信号量的身影：</p>
<p>第一个：mSemaphorePoolThreadHandler = new Semaphore(0);<br>用于控制我们的mPoolThreadHandler的初始化完成，我们在使用mPoolThreadHandler会进行判空，如果为null，会通过<br>mSemaphorePoolThreadHandler.acquire()进行阻塞；当mPoolThreadHandler初始化结束，我们会调<br>用.release();解除阻塞。</p>
<p>第二个：mSemaphoreThreadPool = new<br>Semaphore(threadCount);这个信号量的数量和我们加载图片的线程个数一致；每取一个任务去执行，我们会让信号量减一；每完成一个任<br>务，会让信号量+1，再去取任务；目的是什么呢？为什么当我们的任务到来时，如果此时在没有空闲线程，任务则一直添加到TaskQueue中，当线程完成<br>任务，可以根据策略去TaskQueue中去取任务，只有这样，我们的LIFO才有意义。</p>
<p>到此，我们的图片加载框架就结束了，你可以尝试下加载本地，或者去加载网络大量的图片，拼一拼加载速度~~~</p>
<h1 id="4、MainActivity"><a href="#4、MainActivity" class="headerlink" title="4、MainActivity"></a><a name="t10"></a><a target="_blank" style="color:rgb(51,102,153)" name="t10"></a>4、MainActivity</h1><p>现在是使用的时刻~~</p>
<p>我在MainActivity中，我使用了Fragment，下面我贴下Fragment和布局文件的代码，具体的，大家自己看代码：</p>
<pre class="brush:java;toolbar:false">   package com.example.demo_zhy_18_networkimageloader;  

    import android.content.Context;  
    import android.os.Bundle;  
    import android.support.v4.app.Fragment;  
    import android.util.Log;  
    import android.view.LayoutInflater;  
    import android.view.View;  
    import android.view.ViewGroup;  
    import android.widget.ArrayAdapter;  
    import android.widget.GridView;  
    import android.widget.ImageView;  

    import com.zhy.utils.ImageLoader;  
    import com.zhy.utils.ImageLoader.Type;  
    import com.zhy.utils.Images;  

    public class ListImgsFragment extends Fragment  
    {  
        private GridView mGridView;  
        private String[] mUrlStrs = Images.imageThumbUrls;  
        private ImageLoader mImageLoader;  

        @Override  
        public void onCreate(Bundle savedInstanceState)  
        {  
            super.onCreate(savedInstanceState);  
            mImageLoader = ImageLoader.getInstance(3, Type.LIFO);  
        }  

        @Override  
        public View onCreateView(LayoutInflater inflater, ViewGroup container,  
                Bundle savedInstanceState)  
        {  
            View view = inflater.inflate(R.layout.fragment_list_imgs, container,  
                    false);  
            mGridView = (GridView) view.findViewById(R.id.id_gridview);  
            setUpAdapter();  
            return view;  
        }  

        private void setUpAdapter()  
        {  
            if (getActivity() == null || mGridView == null)  
                return;  

            if (mUrlStrs != null)  
            {  
                mGridView.setAdapter(new ListImgItemAdaper(getActivity(), 0,  
                        mUrlStrs));  
            } else  
            {  
                mGridView.setAdapter(null);  
            }  

        }  

        private class ListImgItemAdaper extends ArrayAdapter&lt;String&gt;  
        {  

            public ListImgItemAdaper(Context context, int resource, String[] datas)  
            {  
                super(getActivity(), 0, datas);  
                Log.e(&quot;TAG&quot;, &quot;ListImgItemAdaper&quot;);  
            }  

            @Override  
            public View getView(int position, View convertView, ViewGroup parent)  
            {  
                if (convertView == null)  
                {  
                    convertView = getActivity().getLayoutInflater().inflate(  
                            R.layout.item_fragment_list_imgs, parent, false);  
                }  
                ImageView imageview = (ImageView) convertView  
                        .findViewById(R.id.id_img);  
                imageview.setImageResource(R.drawable.pictures_no);  
                mImageLoader.loadImage(getItem(position), imageview, true);  
                return convertView;  
            }  

        }  

    }</pre>

<p>可以看到我们在getView中，使用mImageLoader.loadImage一行即完成了图片的加载。</p>
<p>fragment_list_imgs.xml</p>
<pre class="brush:xml;toolbar:false;"> &lt;GridView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:id=&quot;@+id/id_gridview&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:horizontalSpacing=&quot;3dp&quot;  
    android:verticalSpacing=&quot;3dp&quot;  
    android:numColumns=&quot;3&quot;  
   &gt;  

&lt;/GridView&gt;</pre>

<p>item_fragment_list_imgs.xml</p>
<pre class="brush:xml;toolbar:false">    &lt;ImageView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
        android:id=&quot;@+id/id_img&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;120dp&quot;  
        android:scaleType=&quot;centerCrop&quot; &gt;  

    &lt;/ImageView&gt;</pre>

<p><strong><span style="font-size: 24px;">源码下载：</span></strong><a href="http://pan.baidu.com/s/1mgjARkG" target="_blank" rel="external"><strong><span style="font-size: 24px;">http://pan.baidu.com/s/1mgjARkG</span></strong></a></p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/07/15/获取百度网盘真实下载链接/" rel="next" title="获取百度网盘真实下载链接">
                <i class="fa fa-chevron-left"></i> 获取百度网盘真实下载链接
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/07/28/ListItemFold-ListView折叠效果/" rel="prev" title="ListItemFold ListView折叠效果">
                ListItemFold ListView折叠效果 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="wangtao" />
          <p class="site-author-name" itemprop="name">wangtao</p>
          <p class="site-description motion-element" itemprop="description">描述</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、概述"><span class="nav-number">1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、效果图"><span class="nav-number">2.</span> <span class="nav-text">2、效果图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、完全解析"><span class="nav-number">3.</span> <span class="nav-text">3、完全解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、关于图片的压缩"><span class="nav-number">3.1.</span> <span class="nav-text">1、关于图片的压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、本地图片的压缩"><span class="nav-number">3.1.1.</span> <span class="nav-text">1、本地图片的压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、网络图片的压缩"><span class="nav-number">3.1.2.</span> <span class="nav-text">2、网络图片的压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、图片加载框架的架构"><span class="nav-number">3.2.</span> <span class="nav-text">2、图片加载框架的架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、具体的实现"><span class="nav-number">4.</span> <span class="nav-text">3、具体的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、构造方法"><span class="nav-number">4.1.</span> <span class="nav-text">1、构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、loadImage"><span class="nav-number">4.2.</span> <span class="nav-text">2、loadImage</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、MainActivity"><span class="nav-number">5.</span> <span class="nav-text">4、MainActivity</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangtao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  


</body>
</html>
